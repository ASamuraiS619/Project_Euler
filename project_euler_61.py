# -*- coding: utf-8 -*-

'''
Problem61 「Cyclical figurate numbers」

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:

Triangle	 	P(3,n)=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Square	 	    P(4,n)=n^2	 	    1, 4, 9, 16, 25, ...
Pentagonal	 	P(5,n)=n(3n−1)/2	1, 5, 12, 22, 35, ...
Hexagonal	 	P(6,n)=n(2n−1)	 	1, 6, 15, 28, 45, ...
Heptagonal	 	P(7,n)=n(5n−3)/2	1, 7, 18, 34, 55, ...
Octagonal	 	P(8,n)=n(3n−2)	 	1, 8, 21, 40, 65, ...
The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
Each polygonal type: triangle (P(3,127)=8128), square (P(4,91)=8281), and pentagonal (P(5,44)=2882), is represented by a different number in the set.
This is the only set of 4-digit numbers with this property.
Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
(6つの4桁の数からなる循環順列で、それぞれが三角数、四角数、五角数、六角数、七角数、八角数の違うnの値で表される唯一の組み合わせについて、その数たちの合計を求めよ。)
'''

import time
from itertools import combinations, permutations

def is_triangle_number(num):
    if ((-1 + (1 + 8*num) ** 0.5)/2).is_integer():
        return True
    else:
        return False

def is_square_number(num):
    if (num ** 0.5).is_integer():
        return True
    else:
        return False

def is_pentagonal_number(num):
    if ((1 + (1 + 24*num) ** 0.5)/6).is_integer():
        return True
    else:
        return False

def is_hexagonal_number(num):
    if ((1 + (1 + 8*num) ** 0.5)/4).is_integer():
        return True
    else:
        return False

def is_heptagonal_number(num):
    if ((3 + (9 + 40*num) ** 0.5)/10).is_integer():
        return True
    else:
        return False

def is_octagonal_number(num):
    if ((1 + (1 + 3*num) ** 0.5)/3).is_integer():
        return True
    else:
        return False

def start_with_designated_digits(num, first_two_digits):
    return str(num)[:2] == first_two_digits

if __name__ == '__main__':
    start = time.time()

    octagonal_numbers = [num for num in range(1000, 10000) if is_octagonal_number(num)]
    heptagonal_numbers = [num for num in range(1000, 10000) if is_heptagonal_number(num)]
    hexagonal_numbers = [num for num in range(1000, 10000) if is_hexagonal_number(num)]
    pentagonal_numbers = [num for num in range(1000, 10000) if is_pentagonal_number(num)]
    square_numbers = [num for num in range(1000, 10000) if is_square_number(num)]
    triangle_numbers = [num for num in range(1000, 10000) if is_triangle_number(num)]
    figurate_numbers_dict = {(index+3): figurate_numbers for index, figurate_numbers in enumerate([triangle_numbers, square_numbers, pentagonal_numbers, hexagonal_numbers, heptagonal_numbers])}
    figurate_numbers_first_two_digits = {key: set([str(num)[:2] for num in value]) for key, value in figurate_numbers_dict.items()}

    answer_dict = {}
    current_last_two_digit = None
    answer_flag = False
    found_flag = False
    # 一番候補の少ないoctagonal numbersから
    for octagonal_number in octagonal_numbers:
        # それぞれのoctagonal numberについて、triangle〜heptagonalを全順列で探索していく。
        for order in permutations([3, 4, 5, 6, 7]):
            answer_dict = {8: octagonal_number}
            current_last_two_digit = str(octagonal_number)[2:]
            # 104行目でループを次に進めるかどうか判定するためにindexを使用する。
            for index, figurate_number in enumerate(order):
                if current_last_two_digit not in figurate_numbers_first_two_digits[figurate_number]:
                    break
                else:
                    found_flag = False
                    # 上2桁が先の数字の下二桁と一致している数字に関してforループを回す。
                    for number in [num for num in figurate_numbers_dict[figurate_number] if start_with_designated_digits(num, current_last_two_digit)]:
                        # index=4は順列最後なので、冒頭のoctagonal numberと繋がっているかを判定し、繋がっていれば答えを出力。
                        if index == 4:
                            if start_with_designated_digits(number, current_last_two_digit) and start_with_designated_digits(octagonal_number, str(number)[2:]):
                                answer_dict[figurate_number] = number
                                # print(answer_dict)    # {8: 1281, 6: 8128, 5: 2882, 3: 8256, 4: 5625, 7: 2512}
                                print(sum(answer_dict.values()))    # answer 28684
                                answer_flag = True
                                break
                        else:
                            if str(number)[2:] in figurate_numbers_first_two_digits[order[index+1]]:
                                answer_dict[figurate_number] = number
                                current_last_two_digit = str(number)[2:]
                                found_flag = True
                                break
                    # 次の数字が見つからなかった場合は次の順列へ処理を移す。
                    if found_flag == False:
                        break
                if answer_flag == True:
                    break
            if answer_flag == True:
                break
        if answer_flag == True:
            break

    elapsed_time = time.time() - start
    print("elapsed_time:{}".format(round(elapsed_time, 5)) + "[sec]")   # 0.02554sec

